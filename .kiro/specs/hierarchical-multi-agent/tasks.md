# 实施计划

## 概述

基于分层多智能体系统的设计文档，本实施计划将系统开发分解为可管理的编程任务。采用测试驱动开发方法，优先实现核心功能，确保每个步骤都能构建在前一步的基础上。

## 验证方法说明

每个任务都包含详细的验证方法，确保实现质量：

- **功能验证**：验证核心功能是否按预期工作
- **集成验证**：验证组件间的集成是否正确
- **错误处理验证**：验证异常情况的处理是否合适
- **性能验证**：验证关键性能指标是否达标

所有验证项目都应该通过才能认为任务完成。建议为每个验证项目编写自动化测试。

## 需求覆盖检查

### 需求1: 构建分层团队接口
- [x] 任务1.2: 核心数据模型 (实体列表和依赖关系的数据结构)
- [x] 任务4.1: 团队构建器 (创建分层团队结构)
- [x] 任务4.2: 分层管理器 (顶级监督者协调)
- [x] 任务6.1: 团队管理API (HTTP接口)

### 需求2: 触发分层团队执行
- [x] 任务5.1: 执行引擎核心 (执行工作流程)
- [x] 任务5.4: 分层执行协调器 (分层执行逻辑)
- [x] 任务6.2: 执行控制API (触发执行)
- [x] 任务6.3: 流式事件API (实时反馈)
- [x] 任务5.2: 状态管理器 (状态更新)

### 需求3: 标准化输出
- [x] 任务7.1: 结果收集器 (收集执行结果)
- [x] 任务7.2: 模板化输出 (标准化格式)
- [x] 任务6.4: 结果查询API (输出接口)

### 需求4: 灵活的智能体配置
- [x] 任务3.1: 基础智能体类 (自定义智能体)
- [x] 任务3.2: 监督者智能路由 (自定义监督策略)
- [x] 任务3.3: 工具集成框架 (插件化扩展)
- [x] 任务3.4: 工具到智能体集成 (动态工具配置)
- [x] 任务2.2: 多LLM提供商支持 (灵活配置)

### 需求5: 错误处理和恢复机制
- [x] 任务8.1: 错误处理框架 (错误记录和重试)
- [x] 任务8.2: 日志和监控 (详细日志)
- [x] 任务5.1: 执行引擎核心 (优雅停止)
- [x] 任务5.4: 分层执行协调器 (监督者重分配)

## 任务依赖关系

```mermaid
graph TD
    A[1.1 项目结构] --> B[1.2 数据模型]
    A --> C[1.3 配置管理]
    B --> D[2.1 密钥加密]
    B --> E[2.2 LLM提供商]
    D --> F[2.3 密钥API]
    E --> F
    B --> G[3.1 基础智能体]
    D --> G
    E --> G
    B --> H[3.2 监督者路由]
    G --> I[3.3 工具框架]
    G --> J[3.4 工具集成]
    I --> J
    B --> K[4.1 团队构建器]
    G --> K
    H --> K
    K --> L[4.2 分层管理器]
    B --> M[5.1 执行引擎]
    B --> N[5.2 状态管理]
    B --> O[5.3 事件管理]
    G --> P[5.4 分层执行协调器]
    H --> P
    K --> P
    M --> P
    O --> P
    C --> Q[6.1 团队API]
    L --> R[6.2 执行API]
    M --> R
    N --> R
    P --> R
    O --> S[6.3 流式API]
    B --> T[7.1 结果收集]
    N --> T
    T --> U[7.2 模板输出]
    T --> V[6.4 结果API]
    U --> V
    B --> W[8.1 错误处理]
    B --> X[8.2 日志监控]
    Q --> Y[9.1 主应用]
    R --> Y
    S --> Y
    V --> Y
    F --> Y
    W --> Y
    X --> Y
    Y --> Z[9.2 集成测试]
    Z --> AA[9.3 性能优化]
```

## 任务列表 (共34个任务)

- [ ] 1. 项目基础设施和核心数据模型
  - 创建项目结构和依赖管理
  - 实现核心数据模型和配置类
  - _需求: 1.1, 2.1, 3.1_

- [ ] 1.1 设置项目结构和依赖
  - 创建Python项目结构（src/hierarchical_agents/）
  - 配置pyproject.toml，包含LangGraph、LangChain、FastAPI等依赖
  - 设置开发环境配置文件
  - _需求: 1.1_
  - **验证方法:**
    - [ ] 项目结构符合Python包标准（src/hierarchical_agents/__init__.py存在）
    - [ ] `pip install -e .` 成功安装项目
    - [ ] 所有必需依赖可以正常导入：`import langgraph, langchain, fastapi`
    - [ ] 开发工具配置正确：pytest、black、mypy可以运行

- [ ] 1.2 实现核心数据模型
  - 创建data_models.py，实现所有@dataclass定义
  - 包含LLMConfig、AgentConfig、SupervisorConfig、SubTeam等
  - 添加数据验证和序列化支持
  - _需求: 1.1, 2.1_
  - **验证方法:**
    - [ ] 所有数据类可以正常实例化：`LLMConfig(provider="openai", model="gpt-4o", api_key_ref="test")`
    - [ ] Pydantic验证正常工作：无效数据抛出ValidationError
    - [ ] JSON序列化/反序列化正常：`model.model_dump()` 和 `Model.model_validate(data)`
    - [ ] 类型提示通过mypy检查：`mypy src/hierarchical_agents/data_models.py`

- [ ] 1.3 实现配置管理基础
  - 创建config_manager.py，处理配置加载和验证
  - 支持JSON配置文件的读取和解析
  - 实现配置验证逻辑
  - _需求: 1.1_
  - **验证方法:**
    - [ ] 可以加载有效的JSON配置文件：`ConfigManager.load_config("test_config.json")`
    - [ ] 无效配置被正确拒绝并提供清晰错误信息
    - [ ] 配置验证覆盖所有必需字段：team_name、sub_teams、dependencies等
    - [ ] 单元测试覆盖率达到90%以上

- [ ] 2. 密钥管理系统
  - 实现安全的LLM API密钥管理
  - 支持多提供商（OpenAI、OpenRouter、AWS Bedrock）
  - _需求: 4.1, 4.2, 5.1_

- [ ] 2.1 实现密钥加密存储
  - 创建key_manager.py，实现SecureKeyManager类
  - 使用cryptography库实现AES-256加密
  - 实现密钥的安全存储和检索
  - _需求: 4.1, 5.1_
  - **验证方法:**
    - [ ] 密钥加密/解密正常工作：存储的密钥与原始密钥不同，但解密后一致
    - [ ] 密钥引用系统正常：`store_key()` 返回引用，`get_key(ref)` 返回原始密钥
    - [ ] 安全性测试：加密密钥不能从存储中直接读取
    - [ ] 错误处理：无效引用抛出适当异常

- [ ] 2.2 实现多LLM提供商支持
  - 创建llm_providers.py，实现LLMProviderConfig类
  - 支持OpenAI、OpenRouter、AWS Bedrock的客户端创建
  - 实现统一的LLM接口抽象
  - _需求: 4.2_
  - **验证方法:**
    - [ ] OpenAI客户端创建成功：`create_openai_client()` 返回有效的ChatOpenAI实例
    - [ ] OpenRouter客户端创建成功：正确设置base_url和headers
    - [ ] AWS Bedrock客户端创建成功：正确配置region和credentials
    - [ ] 统一接口测试：所有提供商的客户端都实现相同的调用接口

- [ ] 2.3 实现密钥管理API
  - 在FastAPI中添加密钥管理路由
  - 实现POST /api/v1/keys、GET /api/v1/keys、DELETE /api/v1/keys/{key_id}
  - 添加密钥验证和使用统计功能
  - _需求: 4.1, 4.2_
  - _依赖: 2.1, 2.2_
  - **验证方法:**
    - [ ] API端点响应正确：使用pytest和httpx测试所有端点
    - [ ] 请求验证正常：测试无效JSON、缺失字段等场景
    - [ ] 密钥不泄露：验证响应中不包含原始密钥
    - [ ] 使用统计更新：通过单元测试验证统计逻辑
    - [ ] 独立测试：使用Mock KeyManager进行API层测试

- [ ] 3. 智能体和监督者实现
  - 实现基础的智能体和监督者类
  - 集成LLM调用和工具使用
  - _需求: 1.2, 1.3, 4.3_

- [ ] 3.1 实现基础智能体类
  - 创建agents.py，实现WorkerAgent类
  - 集成LLM配置和密钥管理
  - 实现基础的任务执行逻辑
  - _需求: 1.2, 4.3_
  - _依赖: 1.2, 2.1, 2.2_
  - **验证方法:**
    - [ ] 智能体初始化：使用有效配置成功创建WorkerAgent实例
    - [ ] Mock LLM测试：使用Mock LLM客户端验证调用逻辑
    - [ ] 配置集成：验证LLMConfig正确传递给LLM客户端
    - [ ] 错误处理：测试网络错误、API错误等异常场景
    - [ ] 独立测试：不依赖真实LLM API进行单元测试

- [ ] 3.2 实现监督者智能路由
  - 在agents.py中实现SupervisorAgent类
  - 实现基于LLM的智能路由决策
  - 支持结构化输出和路由推理
  - _需求: 1.3, 4.3_
  - **验证方法:**
    - [ ] 路由决策正常工作：给定选项列表，监督者返回有效选择
    - [ ] 结构化输出正确：`route_task_structured()` 返回选择和推理
    - [ ] 路由逻辑合理：相同输入产生一致的路由决策
    - [ ] 边界情况处理：空选项列表或无效选项时的错误处理

- [ ] 3.3 实现工具集成框架
  - 创建tools.py，定义工具接口
  - 实现基础工具（如搜索、文档处理）的集成
  - 支持动态工具加载和执行
  - _需求: 4.3_
  - _依赖: 无_
  - **验证方法:**
    - [ ] 工具接口：定义并测试BaseTool抽象基类
    - [ ] 动态加载：实现工具注册表和加载机制
    - [ ] 基础工具：实现并测试搜索、文档处理工具
    - [ ] 错误隔离：测试工具异常不影响调用者
    - [ ] 工具链：测试多个工具的组合使用

- [ ] 3.4 集成工具到智能体
  - 在agents.py中添加工具使用逻辑
  - 实现智能体调用工具的接口
  - 支持工具结果的处理和传递
  - _需求: 4.3_
  - _依赖: 3.1, 3.3_
  - **验证方法:**
    - [ ] 工具调用：测试智能体正确调用配置的工具
    - [ ] 结果处理：验证工具输出正确传递给LLM
    - [ ] 工具选择：测试智能体根据任务选择合适工具
    - [ ] 异常处理：测试工具失败时的降级处理
    - [ ] 工具链执行：测试复杂的多工具协作场景

- [ ] 4. 团队构建和管理
  - 实现分层团队的构建逻辑
  - 处理依赖关系和执行顺序
  - _需求: 1.1, 1.4_

- [ ] 4.1 实现团队构建器
  - 创建team_builder.py，实现TeamBuilder类
  - 根据配置创建智能体和监督者实例
  - 构建依赖关系图和执行顺序
  - _需求: 1.1, 1.4_
  - _依赖: 1.2, 3.1, 3.2_
  - **验证方法:**
    - [ ] 团队构建：使用Mock智能体工厂测试团队构建逻辑
    - [ ] 依赖图算法：测试拓扑排序和依赖关系验证
    - [ ] 执行顺序：验证生成的顺序满足所有依赖约束
    - [ ] 循环依赖：测试A→B→C→A等循环依赖的检测
    - [ ] 边界情况：测试空配置、单节点、复杂依赖等场景

- [ ] 4.2 实现分层管理器
  - 创建hierarchical_manager.py，实现HierarchicalManager类
  - 集成团队构建、执行引擎和输出格式化
  - 实现build_hierarchy方法
  - _需求: 1.1, 1.4_
  - **验证方法:**
    - [ ] 分层构建成功：`build_hierarchy(config)` 返回完整的HierarchicalTeam
    - [ ] 组件集成正确：团队构建器、执行引擎、输出格式化器正常协作
    - [ ] 接口一致性：所有方法签名与设计文档一致
    - [ ] 集成测试通过：端到端的团队创建和基础执行流程正常

- [ ] 5. 执行引擎和状态管理
  - 实现异步执行引擎
  - 管理执行状态和事件流
  - _需求: 2.1, 2.2, 2.3_

- [ ] 5.1 实现执行引擎核心
  - 创建execution_engine.py，实现ExecutionEngine类
  - 支持异步执行和状态管理
  - 实现执行上下文和会话管理
  - _需求: 2.1, 2.2_
  - **验证方法:**
    - [ ] 异步执行正常：`start_execution()` 返回可等待的协程
    - [ ] 会话管理正确：每次执行创建唯一的execution_id
    - [ ] 状态跟踪准确：执行状态正确从pending→running→completed转换
    - [ ] 并发安全：多个执行可以并发进行而不互相干扰

- [ ] 5.2 实现状态管理器
  - 创建state_manager.py，实现StateManager类
  - 支持执行状态的持久化和查询
  - 集成Redis进行状态缓存
  - _需求: 2.2, 2.3_
  - **验证方法:**
    - [ ] 状态持久化正常：状态更新后可以通过execution_id查询到
    - [ ] Redis集成正确：状态数据正确存储在Redis中
    - [ ] 查询性能良好：状态查询响应时间<100ms
    - [ ] 数据一致性：并发状态更新不会导致数据不一致

- [ ] 5.3 实现事件管理器
  - 创建event_manager.py，实现EventManager类
  - 支持实时事件生成和流式推送
  - 实现事件的分类和格式化
  - _需求: 2.2, 2.3_
  - _依赖: 1.2_
  - **验证方法:**
    - [ ] 事件生成：测试各种事件类型的生成逻辑
    - [ ] 事件格式：验证事件符合ExecutionEvent数据模型
    - [ ] 流式推送：使用asyncio测试事件流推送
    - [ ] 事件分类：验证source_type字段正确设置
    - [ ] 订阅管理：测试订阅者的添加、移除和通知

- [ ] 5.4 实现分层执行协调器
  - 创建hierarchical_executor.py，实现分层执行逻辑
  - 协调顶级监督者→子团队监督者→智能体的执行流程
  - 处理依赖关系和执行顺序
  - _需求: 1.1, 2.1, 2.2_
  - _依赖: 3.1, 3.2, 4.1, 5.1, 5.3_
  - **验证方法:**
    - [ ] 分层执行：测试完整的三层执行流程
    - [ ] 依赖处理：验证依赖团队完成后才执行下游团队
    - [ ] 路由决策：测试监督者的智能路由功能
    - [ ] 状态同步：验证执行状态在各层间正确传递
    - [ ] 错误传播：测试错误在分层结构中的传播和处理

- [ ] 6. HTTP API接口实现
  - 实现所有REST API端点
  - 集成请求验证和响应格式化
  - _需求: 1.1, 2.1, 3.1_

- [ ] 6.1 实现团队管理API
  - 创建api/teams.py，实现团队创建接口
  - POST /api/v1/hierarchical-teams
  - 集成请求验证和团队构建逻辑
  - _需求: 1.1_
  - **验证方法:**
    - [ ] API响应格式正确：返回符合设计的JSON结构和状态码
    - [ ] 请求验证有效：无效请求返回400错误和详细错误信息
    - [ ] 团队创建成功：有效请求成功创建团队并返回team_id
    - [ ] OpenAPI文档生成：FastAPI自动生成正确的API文档

- [ ] 6.2 实现执行控制API
  - 创建api/executions.py，实现执行相关接口
  - POST /api/v1/hierarchical-teams/{team_id}/execute
  - GET /api/v1/executions/{execution_id}
  - _需求: 2.1_
  - _依赖: 4.2, 5.1, 5.2, 5.4_
  - **验证方法:**
    - [ ] 执行启动：使用Mock执行引擎测试API逻辑
    - [ ] 状态查询：验证从StateManager正确获取状态
    - [ ] 参数验证：测试无效ID的错误处理
    - [ ] 异步处理：验证API立即返回而不等待执行完成
    - [ ] 集成测试：端到端测试执行启动和状态查询

- [ ] 6.3 实现流式事件API
  - 在api/executions.py中添加流式接口
  - GET /api/v1/executions/{execution_id}/stream (SSE)
  - 集成事件管理器和实时推送
  - _需求: 2.2_
  - _依赖: 5.3_
  - **验证方法:**
    - [ ] SSE连接：使用httpx测试SSE连接建立
    - [ ] 事件推送：模拟事件生成并验证SSE推送
    - [ ] 格式规范：验证事件符合Server-Sent Events标准
    - [ ] 连接管理：测试客户端断开时的资源清理
    - [ ] 并发连接：测试多个客户端同时连接的处理

- [ ] 6.4 实现结果查询API
  - 在api/executions.py中添加结果接口
  - GET /api/v1/executions/{execution_id}/results
  - POST /api/v1/executions/{execution_id}/results/format
  - _需求: 3.1_
  - **验证方法:**
    - [ ] 原始结果查询：GET接口返回完整的执行结果数据
    - [ ] 模板化输出：POST接口根据用户模板生成格式化报告
    - [ ] 模板验证：无效模板返回400错误和清晰错误信息
    - [ ] 结果完整性：返回的结果包含所有团队和智能体的输出

- [ ] 7. 结果处理和格式化
  - 实现结果收集和标准化输出
  - 支持模板化报告生成
  - _需求: 3.1, 3.2, 3.3_

- [ ] 7.1 实现结果收集器
  - 创建output_formatter.py，实现OutputFormatter类
  - 收集所有团队和智能体的执行结果
  - 生成标准化的执行摘要和指标
  - _需求: 3.1, 3.3_
  - _依赖: 1.2, 5.2_
  - **验证方法:**
    - [ ] 结果收集：使用Mock执行数据测试收集逻辑
    - [ ] 摘要生成：验证ExecutionSummary的各字段计算
    - [ ] 指标计算：测试token、API调用等指标的统计
    - [ ] 数据模型：验证输出符合StandardizedOutput结构
    - [ ] 边界情况：测试空结果、部分失败等场景

- [ ] 7.2 实现模板化输出
  - 在output_formatter.py中添加模板处理
  - 支持用户自定义JSON模板
  - 实现智能的信息提取和格式化
  - _需求: 3.2_
  - **验证方法:**
    - [ ] 模板解析正确：用户提供的JSON模板被正确解析
    - [ ] 信息提取准确：根据extraction_rules正确提取信息
    - [ ] 格式化输出：生成的报告符合用户指定的结构
    - [ ] 错误处理：模板中的无效字段或规则被正确处理

- [ ] 8. 错误处理和监控
  - 实现全面的错误处理机制
  - 添加日志记录和监控功能
  - _需求: 5.1, 5.2, 5.3, 5.4_

- [ ] 8.1 实现错误处理框架
  - 创建error_handler.py，实现ErrorHandler类
  - 支持智能体错误、网络错误、监督者失效的处理
  - 实现重试机制和降级处理
  - _需求: 5.1, 5.2_
  - **验证方法:**
    - [ ] 错误分类正确：不同类型的错误被正确识别和分类
    - [ ] 重试机制有效：可恢复错误触发重试，不可恢复错误直接失败
    - [ ] 降级处理：关键组件失效时系统能够降级运行
    - [ ] 错误传播：错误信息正确传播到上层调用者

- [ ] 8.2 实现日志和监控
  - 集成结构化日志记录
  - 添加执行指标收集和统计
  - 实现审计日志功能
  - _需求: 5.3, 5.4_
  - **验证方法:**
    - [ ] 日志格式标准：所有日志采用结构化格式（JSON）
    - [ ] 日志级别正确：不同重要性的事件使用适当的日志级别
    - [ ] 指标收集准确：执行指标被正确收集和统计
    - [ ] 审计完整性：所有关键操作都有审计日志记录

- [ ] 9. 系统集成和测试
  - 集成所有组件并进行端到端测试
  - 验证完整的工作流程
  - _需求: 1.1, 2.1, 3.1, 4.1, 5.1_

- [ ] 9.1 实现主应用入口
  - 创建main.py，集成FastAPI应用
  - 配置所有路由和中间件
  - 实现应用启动和关闭逻辑
  - _需求: 1.1, 2.1, 3.1_
  - **验证方法:**
    - [ ] 应用启动成功：`uvicorn main:app` 成功启动服务
    - [ ] 所有路由可访问：API文档显示所有定义的端点
    - [ ] 中间件正常：CORS、日志、错误处理中间件正常工作
    - [ ] 优雅关闭：应用可以正确处理关闭信号并清理资源

- [ ] 9.2 端到端集成测试
  - 创建完整的工作流测试
  - 测试从团队创建到结果输出的完整流程
  - 验证流式事件和错误处理
  - _需求: 1.1, 1.2, 1.3, 1.4, 2.1, 2.2, 2.3, 3.1, 3.2, 3.3, 4.1, 4.2, 4.3, 5.1, 5.2, 5.3, 5.4_
  - _依赖: 所有前置任务_
  - **验证方法:**
    - [ ] 需求1验证：测试分层团队构建的完整功能
    - [ ] 需求2验证：测试执行触发和流式反馈功能
    - [ ] 需求3验证：测试标准化输出和模板化报告
    - [ ] 需求4验证：测试智能体配置和工具集成的灵活性
    - [ ] 需求5验证：测试错误处理和系统稳定性
    - [ ] 性能测试：验证系统在负载下的表现
    - [ ] 兼容性测试：测试不同LLM提供商的兼容性

- [ ] 9.3 性能优化和监控集成
  - 添加性能监控和指标收集
  - 优化并发执行和资源使用
  - 集成Prometheus监控（可选）
  - _需求: 4.1, 5.1_
  - **验证方法:**
    - [ ] 性能指标收集：关键性能指标被正确收集和暴露
    - [ ] 并发性能良好：系统可以处理多个并发执行请求
    - [ ] 资源使用合理：内存和CPU使用在正常范围内
    - [ ] 监控集成成功：Prometheus可以正确抓取指标数据